import { GoogleGenerativeAI } from '@google/generative-ai';
import { LLMService } from './llmService.js';
import { logger, colors } from './logger.js';

/**
 * Gemini API Service
 * Uses Google's Generative AI SDK to convert HTML to Markdown via API calls
 */
export class GeminiApiService extends LLMService {
  /**
   * Create a new Gemini API service
   * @param {string} apiKey - The Google Generative AI API key
   * @param {string} modelName - The model to use (default: gemini-1.5-flash)
   */
  constructor(apiKey, modelName = 'gemini-1.5-flash') {
    super();

    if (!apiKey) {
      throw new Error('GEMINI_API_KEY is required for GeminiApiService');
    }

    this.apiKey = apiKey;
    this.modelName = modelName;
    this.genAI = new GoogleGenerativeAI(apiKey);
    this.model = this.genAI.getGenerativeModel({ model: modelName });
  }

  /**
   * Get the service name for logging
   * @returns {string}
   */
  getServiceName() {
    return 'GeminiAPI';
  }

  /**
   * Convert HTML to Markdown using the Gemini API
   * @param {string} html - The HTML content to convert
   * @param {string} url - The source URL (for logging)
   * @returns {Promise<string>} - The converted Markdown content
   */
  async convertHtmlToMarkdown(html, url) {
    const serviceName = this.getServiceName();
    console.log(colors.cyan(`Using ${serviceName} service (${this.modelName})`));
    const totalStart = Date.now();

    await logger.info(`Starting ${serviceName} API call`, {
      url,
      htmlLength: html.length,
      model: this.modelName,
      timestamp: new Date().toISOString()
    });

    try {
      // Build the prompt
      const promptStart = Date.now();
      const prompt = this.buildConversionPrompt(html);
      const promptTime = Date.now() - promptStart;
      console.log(colors.dim(`Prompt prepared (${promptTime}ms, ${html.length} chars HTML)`));

      await logger.debug(`${serviceName} API request details`, {
        promptLength: prompt.length,
        htmlLength: html.length,
        truncated: html.length > 50000,
        model: this.modelName
      });

      // Make the API call
      const apiStart = Date.now();
      const result = await this.model.generateContent(prompt);
      const response = result.response;
      const apiTime = Date.now() - apiStart;

      console.log(colors.success(`API call complete (${apiTime}ms)`));

      // Extract the generated text
      const parseStart = Date.now();
      const generatedText = response.text().trim();

      if (!generatedText) {
        await logger.error(`No content generated by ${serviceName}`, {
          url,
          model: this.modelName,
          response: JSON.stringify(response)
        });
        throw new Error(`No content generated by ${serviceName} API`);
      }

      const parseTime = Date.now() - parseStart;
      const totalTime = Date.now() - totalStart;

      console.log(colors.dim(`Response parsed (${parseTime}ms) | Total: ${totalTime}ms | Output: ${generatedText.length} chars`));

      await logger.info(`${serviceName} processing complete`, {
        url,
        totalTime,
        apiTime,
        outputLength: generatedText.length,
        model: this.modelName
      });

      return generatedText;

    } catch (error) {
      const totalTime = Date.now() - totalStart;

      await logger.error(`${serviceName} API error`, {
        url,
        error: error.message,
        stack: error.stack,
        totalTime,
        model: this.modelName
      });

      console.log(colors.error(`Error calling ${serviceName} API: ${error.message}`));
      throw error;
    }
  }
}
