import { jest } from '@jest/globals';
import { OllamaService } from '../ollamaService.js';

// Mock fetch globally
global.fetch = jest.fn();

describe('OllamaService', () => {
  let service;
  const mockBaseUrl = 'http://localhost:11434';
  const mockModel = 'llama2';

  beforeEach(() => {
    service = new OllamaService(mockBaseUrl, mockModel);
    jest.clearAllMocks();
  });

  describe('constructor', () => {
    test('creates service with default parameters', () => {
      const defaultService = new OllamaService();
      expect(defaultService.baseUrl).toBe('http://localhost:11434');
      expect(defaultService.model).toBe('llama2');
    });

    test('creates service with custom parameters', () => {
      const customService = new OllamaService('http://custom:8080', 'mistral');
      expect(customService.baseUrl).toBe('http://custom:8080');
      expect(customService.model).toBe('mistral');
    });

    test('removes trailing slash from base URL', () => {
      const serviceWithSlash = new OllamaService('http://localhost:11434/');
      expect(serviceWithSlash.baseUrl).toBe('http://localhost:11434');
    });
  });

  describe('getServiceName', () => {
    test('returns correct service name', () => {
      expect(service.getServiceName()).toBe('Ollama');
    });
  });

  describe('convertHtmlToMarkdown', () => {
    const mockHtml = '<h1>Test Title</h1><p>Test content</p>';
    const mockUrl = 'https://example.com/test';

    beforeEach(() => {
      // Reset console.log mock
      jest.spyOn(console, 'log').mockImplementation(() => {});
    });

    afterEach(() => {
      console.log.mockRestore();
    });

    test('successfully converts HTML to markdown', async () => {
      const mockResponse = {
        response: '# Test Title\n\nTest content'
      };

      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      const result = await service.convertHtmlToMarkdown(mockHtml, mockUrl);

      expect(result).toBe('# Test Title\n\nTest content');
      expect(global.fetch).toHaveBeenCalledWith(
        'http://localhost:11434/api/generate',
        expect.objectContaining({
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: expect.stringContaining(mockModel)
        })
      );
    });

    test('sends correct prompt to Ollama API', async () => {
      const mockResponse = { response: 'converted text' };

      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      await service.convertHtmlToMarkdown(mockHtml, mockUrl);

      const fetchCall = global.fetch.mock.calls[0];
      const requestBody = JSON.parse(fetchCall[1].body);

      expect(requestBody.model).toBe(mockModel);
      expect(requestBody.stream).toBe(false);
      expect(requestBody.prompt).toContain('Extract the main article content');
      expect(requestBody.prompt).toContain(mockHtml);
    });

    test('handles large HTML by truncating', async () => {
      const largeHtml = 'a'.repeat(60000);
      const mockResponse = { response: 'converted' };

      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      await service.convertHtmlToMarkdown(largeHtml, mockUrl);

      const fetchCall = global.fetch.mock.calls[0];
      const requestBody = JSON.parse(fetchCall[1].body);

      expect(requestBody.prompt).toContain('[HTML truncated - too large]');
    });

    test('throws error when Ollama API returns error status', async () => {
      global.fetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        text: async () => 'Internal Server Error'
      });

      await expect(
        service.convertHtmlToMarkdown(mockHtml, mockUrl)
      ).rejects.toThrow('Ollama API error (500): Internal Server Error');
    });

    test('throws error when response is empty', async () => {
      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ response: '' })
      });

      await expect(
        service.convertHtmlToMarkdown(mockHtml, mockUrl)
      ).rejects.toThrow('No content generated by Ollama API');
    });

    test('throws error when response is null', async () => {
      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ response: null })
      });

      await expect(
        service.convertHtmlToMarkdown(mockHtml, mockUrl)
      ).rejects.toThrow('No content generated by Ollama API');
    });

    test('handles network errors', async () => {
      global.fetch.mockRejectedValueOnce(new Error('Network failure'));

      await expect(
        service.convertHtmlToMarkdown(mockHtml, mockUrl)
      ).rejects.toThrow('Network failure');
    });

    test('trims whitespace from response', async () => {
      const mockResponse = {
        response: '  \n# Title\n\nContent\n  '
      };

      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      const result = await service.convertHtmlToMarkdown(mockHtml, mockUrl);

      expect(result).toBe('# Title\n\nContent');
    });

    test('logs progress messages', async () => {
      const mockResponse = { response: 'result' };

      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      await service.convertHtmlToMarkdown(mockHtml, mockUrl);

      expect(console.log).toHaveBeenCalledWith(
        expect.stringContaining('Ollama')
      );
    });

    test('works with different models', async () => {
      const mistralService = new OllamaService(mockBaseUrl, 'mistral');
      const mockResponse = { response: 'result' };

      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      await mistralService.convertHtmlToMarkdown(mockHtml, mockUrl);

      const fetchCall = global.fetch.mock.calls[0];
      const requestBody = JSON.parse(fetchCall[1].body);

      expect(requestBody.model).toBe('mistral');
    });

    test('works with different base URLs', async () => {
      const customService = new OllamaService('http://custom:8080', 'llama2');
      const mockResponse = { response: 'result' };

      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      await customService.convertHtmlToMarkdown(mockHtml, mockUrl);

      expect(global.fetch).toHaveBeenCalledWith(
        'http://custom:8080/api/generate',
        expect.any(Object)
      );
    });
  });

  describe('buildConversionPrompt integration', () => {
    test('uses base class prompt builder', async () => {
      const mockResponse = { response: 'result' };
      const html = '<p>test</p>';

      global.fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      await service.convertHtmlToMarkdown(html, 'https://example.com');

      const fetchCall = global.fetch.mock.calls[0];
      const requestBody = JSON.parse(fetchCall[1].body);

      // Verify it uses the base class prompt format
      expect(requestBody.prompt).toContain('Extract the main article content');
      expect(requestBody.prompt).toContain('Focus on: title, headings');
      expect(requestBody.prompt).toContain('Return only clean Markdown');
    });
  });
});
